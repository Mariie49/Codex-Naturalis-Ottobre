package cards;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;

import game.PlayArea;
import game.PlayArea.PlayAreaItem;

public class ObjectiveCard extends Card {

	private CardType type = CardType.OBJECTIVE;
	private RequirementType requirementType;
	private ArrayList<Symbol> symbolRequirement;
	private ArrayList<SpecialSymbol> specialSymbolRequirement;
	private Object[][] positionRequirement;
	private int pointsPerRequirement = 999;
	
	
	// Metodo importantissimo che calcola i punti in base alla PlayArea;
	@Override
	public int calculateObjectiveCardPoints (PlayArea playArea) {
		int points = 0;
		
		switch (this.requirementType) {
		
			case SYMBOL_REQUIREMENT:
				points = pointsPerRequirement * quanteLista1ContenutaInLista2(this.symbolRequirement,playArea.getSymbolList());
			break;
			case SPECIALSYMBOL_REQUIREMENT:
				points = pointsPerRequirement * quanteLista1ContenutaInLista2(this.specialSymbolRequirement,playArea.getSpecialSymbolList());
			break;
			case POSITION_REQUIREMENT:
				/* Il position requirement è strutturato in questo modo:
					Ogni carta obiettivo con requisiti sulla posizione delle carte contiene le 3 carti collocate in 3 posizioni (x,y).
					Queste posizioni partono da una (0,0), scelta in maniera arbitraria.
					Quando si controlla se esistono, nella PlayArea del giocatore, dei gruppi di carte che seguono questo pattern
					si fa il controllo solo sul BOTTOM_LEFT corner, così da definire una posizione univoca per la carta nel campo di gioco.
					
					!!! Ogni carta va contata una sola volta, per massimizzare il numero di punti devo ciclare su una playArea ordinata
					Storia della massimizzazione del numero di pattern individuati
				*/
				boolean debugMode = true;
				
				//Uso il metodo playArea.getSortedPlayAreaItems per ottenere la play area ordinata
				ArrayList<PlayAreaItem> l_sortedPlayAreaItems = playArea.getSortedPlayArea();
				ArrayList<PlayAreaItem> l_sortedPlayAreaItems_filtered = l_sortedPlayAreaItems;
				
				// Tanto per cominciare, eseguo l'algoritmo finchè trovo pattern buoni:
				int numeroPatternTrovati = 0;
			
				// Ciclo su tutta la playArea prendendo il PlayAreaItem, controllo i candidati "punti di partenza" dai quali partire per controllare tutto
				for (PlayAreaItem playAreaItem_0 : l_sortedPlayAreaItems) {
					if (debugMode) {System.out.println("Corner di partenza: ( " + playAreaItem_0.getCoordinates().getX() + " , "+playAreaItem_0.getCoordinates().getY()+" )");
									System.out.print(", con carta di tipo: " + playAreaItem_0.getCard().getKingdom());} 
					// Per ogni round di ricerca salvo le carte che ho controllato così che se trovo l'intero pattern che cerco
					// le elimino dalla l_sortedPlayAreaItems (ogni carta può essere contata una volta sola in uno stesso tipo di pattern)
					ArrayList<Coordinates> checkedCoordinates = new ArrayList<>();
					
					// Verifico subito che quel punto sia bottom left E, se non lo è lo lascio perdere in partenza
					if ( ! (playAreaItem_0.getCornerPosition() == CornerPosition.BOTTOM_LEFT)){
						continue;
					}					
					if (debugMode) {System.out.println("Il punto ( " + playAreaItem_0.getCoordinates().getX() + " , "
									+ playAreaItem_0.getCoordinates().getY() + " ), è BOTTOM_LEFT! VADO AVANTI!!... ");} 
					
					boolean conditionsSatisfied = true;
					// Ciclo sui "positionRequirements" della Objective card che intendo controllare.
					for (Object[] singleRequirement : this.positionRequirement) { 
						
						// Estraggo le coordinate e il simbolo dal singleRequirement:
						Coordinates requirementCoordinates = (Coordinates)singleRequirement[0];
						Symbol requirementSymbol = (Symbol)singleRequirement[1];
						

						if (debugMode) {System.out.println("Single Requirement con coordinate: ( " + requirementCoordinates.getX() + " , "+requirementCoordinates.getY()+" )");
										System.out.print(" e simbolo: "+requirementSymbol.toString());}
						
						// Calcolo il punto della playArea che intendo veramente controllare sommando le coordinate del pattern
						int x_toCheck = playAreaItem_0.getCoordinates().getX() + requirementCoordinates.getX();
						int y_toCheck = playAreaItem_0.getCoordinates().getX() + requirementCoordinates.getY();
						
						// Verifico subito che quel punto sia BOTTOM_LEFT e ABBIA
						
						if (debugMode) {System.out.println(" Cerco il punto che nella PlayArea ha coordinate: (" + x_toCheck + " , " + y_toCheck + " )");}
						
						boolean trovato = false; // booleanino per vedere se ho trovato il punto
						// Frugo tutta la l_sortedPlayAreaItems per vedere se trovo un punto a quelle coordinate con quel simbolo
						for (PlayAreaItem item : l_sortedPlayAreaItems_filtered) {
							
							// Se non ha le coordinate uguali e non è un BOTTOM_LEFT e la carta non è iniziale lascio perdere e proseguo con gli altri punti
							if ( ! ( item.getCoordinates().getX() == x_toCheck && item.getCoordinates().getY() == y_toCheck &&
									item.getCornerPosition() == CornerPosition.BOTTOM_LEFT && item.getCard().getType() != CardType.STARTING)) {
								continue;
							}
							if (debugMode) {System.out.println("Trovato il punto. Requirement: "+requirementSymbol.toString()+", Carta: "+item.getCard().getKingdom());}
							
							// Se non appartiene al medesimo regno proseguo con gli altri punti
							// NB Devo controllare LA CARTA, non il corner
							if ( ! ( item.getCard().getKingdom().toString() == requirementSymbol.toString())) {
								continue;
							}
							
							if (debugMode) {System.out.println("Trovato punto con stesso requirement!!, il ( " + x_toCheck + " , " + y_toCheck + " )\n");}
							
							// Se sono arrivato fino a qui, cioè se ho trovato una carta, nella giusta posizione, con il giusto simbolo
							// Allora dichiaro di aver trovato ciò che cercavo
							trovato = true;
							
							// Esco dal ciclo
							break;
						}// fine ricerca della carta nella playarea che soddisfa le condizioni della singola carta nel pattern
						
						// Ho finito di cercare nella playarea, se ho trovato la carta allora bene:
						// Salvo la carta che soddisfa le condizioni richieste e vado avanti con la ricerca della carta successiva,
						// cioè quella dopo nel pattern della ObjectiveCard
						// Se invece non ho trovato nulla, allora trovato sarà false, in questo caso posso rompere anche questo for e dire che
						// la condizione per ottenere dei punti non è soddisfatta:
						if (trovato) {
							// Salvo la carta nelle checked coordinates
							checkedCoordinates.add(new Coordinates(x_toCheck,y_toCheck));
						}
						else { // Se trovato è falso devo smettere di testare requirements partendo dalla carta corrispondente al playAreaItem_0
							// memorizzo il fatto che la carta della playarea dalla quale sono partito a testare le condizioni,
							// cioè la playAreaItem_0, non soddisfa le condizioni
							conditionsSatisfied = false;
							break;								
						}
					}// fine del ciclo sulle carte mostrate sulla ObjectiveCard che compongono il pattern
					
					/*
						A questo punto devo agire in base alla conditionsSatisfied.
						Se è true vuol dire che tutto è andato liscio e che il pattern è stato trovato sulla playarea, partendo dalla playAreaItem_0
						devo: 	1) incrementare il counter numeroPatternTrovati
								2) cancellare dalla l_sortedPlayAreaItems le carte che appartengono al pattern che ho matchato
						Se è false vuol dire che dalla carta dalla quale sono partito: playAreaItem_0, non parte nessun pattern simile a quello
						che sto cercando. Niente, vado avanti e testo un'altra carta della PlayArea.
					*/
					if (conditionsSatisfied) {
					    numeroPatternTrovati++;

					    //Iterator<PlayAreaItem> iterator = l_sortedPlayAreaItems.iterator();
					    for (PlayAreaItem playAreaItem_toDelete : l_sortedPlayAreaItems_filtered) {
					        for (Coordinates Coordinates_toDelete : checkedCoordinates) {
					            if (playAreaItem_toDelete.getCoordinates().getX() == Coordinates_toDelete.getX() &&
					                playAreaItem_toDelete.getCoordinates().getY() == Coordinates_toDelete.getY()) {
					            	l_sortedPlayAreaItems_filtered.remove(playAreaItem_toDelete);
					                break;
					            }
					        }
					    }
					}
					else {
						//Niente, vado avanti e testo un'altra carta della PlayArea.
					}
				} // fine del ciclo che cerca i punti di partenza per la ricerca dei pattern.
			
				points = pointsPerRequirement * numeroPatternTrovati;			
		break;
		
		default:
            throw new IllegalArgumentException("RequirementType non riconosciuto");		
		}			
		return points;
	}
	
	@Override
	public void printCard() {		
		
		System.out.println("\nObjective card numero: " + this.getNumber());
		System.out.println("Requirement type : " + this.getRequirementType()+", "+this.getPointsPerRequirement() +" punti per ogni : ");
		
		switch (this.getRequirementType()) {
			case SYMBOL_REQUIREMENT:
				System.out.println(this.getSymbolRequirement());
			break;
			case SPECIALSYMBOL_REQUIREMENT:
				System.out.println(this.getSpecialSymbolRequirement());
			break;
			case POSITION_REQUIREMENT:
				// Questo è tosto, devo creare una griglia 3x3 per stampare tutto e poi mettere dentro i kingdom corrispondenti
				
			    // Creazione della griglia vuota 3x3 (son tutte stringhe)
			    String[][] grid = new String[3][3];
			    
			    // Inizializzo tutto con 3 spazi, che è la lunghezza degli abbreviated kingdoms
			    for (int j = 0; j < 3; j++) {
			        for (int i = 0; i < 3; i++) {
			            grid[j][i] = "   ";  // j corrisponde a y (-y a dire il vero) e i corrisponde a x
			        }
			    }

			    // Trovo il minimo valore di x e y nelle coordinate
			    int minX = Integer.MAX_VALUE;
			    int minY = Integer.MAX_VALUE;
			    for (Object[] req : positionRequirement) { // Ciclo sui positionrequirements
			        Coordinates coord = (Coordinates) req[0]; // Estraggo il primo valore che son le coordinate (Coordinates)
			        // Confronto con il minimo salvato e sostituisco nel caso.
			        int x = coord.getX();
		            int y = coord.getY();
		            if (x < minX) { minX = x; }
		            if (y < minY) { minY = y; }
			    }

			    // Riempio la griglia con le coordinare relative!
			    for (Object[] req : positionRequirement) { // Ciclo sui position requirements
			        Coordinates coord = (Coordinates) req[0]; // estraggo le coordinate
			        Symbol symbol = (Symbol) req[1]; // estraggo il simbolo
			        String abbreviatedSymbol = symbol.getAbbreviation(); // estraggo l'abbreviazione, che è una stringa
			        
			        // Calcolo le coordinate relative rispetto ai minimi trovati
			        int x = coord.getX() - minX;
			        int y = coord.getY() - minY;
			        
			        // Devo invertire y (che deve andare dal basso verso l'alto), mi trovo e controllo che la griglia sia 3x3
			        if (x >= 0 && x < 3 && y >= 0 && y < 3) {
			            grid[2 - y][x] = abbreviatedSymbol; // 2 - y per invertire l'asse Y
			        } else {
			            System.err.println("Coordinate fuori dalla griglia: (" + coord.getX() + ", " + coord.getY() + ") carta: " + this.getNumber());
			        }
			    }

			    // Stampa della griglia
			    System.out.println();
			    for (int j = 0; j < 3; j++) {
			        for (int i = 0; i < 3; i++) {
			            System.out.print(grid[j][i] + " ");
			        }
			        System.out.println(); // A capo dopo ogni riga
			    }
				
				
			break;
		}
		
	}

    // Costruttore che accetta int n
    public ObjectiveCard(int n) {
        // Imposta i valori in base a n
    	this.setNumber(n);
        switch(n) {
            case 1:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.POSITION_REQUIREMENT);
                this.setPositionRequirement(new Object[][] {
                    {new Coordinates(0, 0), Symbol.FUNGI_KINGDOM},
                    {new Coordinates(1, 1), Symbol.FUNGI_KINGDOM},
                    {new Coordinates(2, 2), Symbol.FUNGI_KINGDOM}
                });
                break;
            case 2:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.POSITION_REQUIREMENT);
                this.setPositionRequirement(new Object[][] {
                    {new Coordinates(0, 0), Symbol.PLANT_KINGDOM},
                    {new Coordinates(-1, 1), Symbol.PLANT_KINGDOM},
                    {new Coordinates(-2, 2), Symbol.PLANT_KINGDOM}
                });
                break;
            case 3:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.POSITION_REQUIREMENT);
                this.setPositionRequirement(new Object[][] {
                    {new Coordinates(0, 0), Symbol.ANIMAL_KINGDOM},
                    {new Coordinates(1, 1), Symbol.ANIMAL_KINGDOM},
                    {new Coordinates(2, 2), Symbol.ANIMAL_KINGDOM}
                });
                break;
            case 4:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.POSITION_REQUIREMENT);
                this.setPositionRequirement(new Object[][] {
                    {new Coordinates(0, 0), Symbol.INSECT_KINGDOM},
                    {new Coordinates(-1, 1), Symbol.INSECT_KINGDOM},
                    {new Coordinates(-2, 2), Symbol.INSECT_KINGDOM}
                });
                break;
            case 5:
            	this.setPointsPerRequirement(3);
                this.setRequirementType(RequirementType.POSITION_REQUIREMENT);
                this.setPositionRequirement(new Object[][] {
                    {new Coordinates(0, 0), Symbol.PLANT_KINGDOM},
                    {new Coordinates(-1, 1), Symbol.FUNGI_KINGDOM},
                    {new Coordinates(1, 2), Symbol.FUNGI_KINGDOM}
                });
                break;
            case 6:
            	this.setPointsPerRequirement(3);
                this.setRequirementType(RequirementType.POSITION_REQUIREMENT);
                this.setPositionRequirement(new Object[][] {
                    {new Coordinates(0, 0), Symbol.PLANT_KINGDOM},
                    {new Coordinates(1, 1), Symbol.PLANT_KINGDOM},
                    {new Coordinates(1, 2), Symbol.INSECT_KINGDOM}
                });
                break;
            case 7:
            	this.setPointsPerRequirement(3);
                this.setRequirementType(RequirementType.POSITION_REQUIREMENT);
                this.setPositionRequirement(new Object[][] {
                    {new Coordinates(0, 0), Symbol.ANIMAL_KINGDOM},
                    {new Coordinates(0, 1), Symbol.ANIMAL_KINGDOM},
                    {new Coordinates(1, 2), Symbol.FUNGI_KINGDOM}
                });
                break;
            case 8:
            	this.setPointsPerRequirement(3);
                this.setRequirementType(RequirementType.POSITION_REQUIREMENT);
                this.setPositionRequirement(new Object[][] {
                    {new Coordinates(0, 0), Symbol.INSECT_KINGDOM},
                    {new Coordinates(0, 1), Symbol.INSECT_KINGDOM},
                    {new Coordinates(-1, 2), Symbol.ANIMAL_KINGDOM}
                });
                break;
            case 9:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.SYMBOL_REQUIREMENT);
                this.setSymbolRequirement(new ArrayList<>(Arrays.asList(
                		Symbol.FUNGI_KINGDOM, Symbol.FUNGI_KINGDOM, Symbol.FUNGI_KINGDOM)));
                break;
            case 10:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.SYMBOL_REQUIREMENT);
                this.setSymbolRequirement(new ArrayList<>(Arrays.asList(
                		Symbol.PLANT_KINGDOM, Symbol.PLANT_KINGDOM, Symbol.PLANT_KINGDOM)));
                break;
            case 11:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.SYMBOL_REQUIREMENT);
                this.setSymbolRequirement(new ArrayList<>(Arrays.asList(
                		Symbol.ANIMAL_KINGDOM, Symbol.ANIMAL_KINGDOM, Symbol.ANIMAL_KINGDOM)));
                break;
            case 12:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.SYMBOL_REQUIREMENT);
                this.setSymbolRequirement(new ArrayList<>(Arrays.asList(
                		Symbol.INSECT_KINGDOM, Symbol.INSECT_KINGDOM, Symbol.INSECT_KINGDOM)));
                break;
            case 13:
            	this.setPointsPerRequirement(3);
                this.setRequirementType(RequirementType.SPECIALSYMBOL_REQUIREMENT);
                this.setSpecialSymbolRequirement(new ArrayList<>(Arrays.asList(
                		SpecialSymbol.QUILL, SpecialSymbol.INKWELL, SpecialSymbol.MANUSCRIPT)));
                break;
            case 14:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.SPECIALSYMBOL_REQUIREMENT);
                this.setSpecialSymbolRequirement(new ArrayList<>(Arrays.asList(
                		SpecialSymbol.MANUSCRIPT, SpecialSymbol.MANUSCRIPT)));
                break;
            case 15:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.SPECIALSYMBOL_REQUIREMENT);
                this.setSpecialSymbolRequirement(new ArrayList<>(Arrays.asList(
                		SpecialSymbol.INKWELL, SpecialSymbol.INKWELL)));
                break;
            case 16:
            	this.setPointsPerRequirement(2);
                this.setRequirementType(RequirementType.SPECIALSYMBOL_REQUIREMENT);
                this.setSpecialSymbolRequirement(new ArrayList<>(Arrays.asList(
                		SpecialSymbol.QUILL, SpecialSymbol.QUILL)));
                break;

            // Altri casi per eventuali altre regole
            default:
                throw new IllegalArgumentException("Valore di n non valido!");
            
        }
    }
    
    public static <T> int quanteLista1ContenutaInLista2(ArrayList<T> lista1, ArrayList<T> lista2) {
        // copia della lista
        ArrayList<T> tempLista2 = new ArrayList<>(lista2);
        Boolean bContenuta = true;
        int nListe1InLista2 = 0;
        
        while (bContenuta) {
	        for (T item : lista1) {
	            if (!tempLista2.contains(item)) {
	            	bContenuta = false; // Se un elemento di lista1 non c'è in lista 2 ferma il ciclo
	            	break;
	            } else {
	                // Se l'elemento esiste, rimuovilo da tempLista2
	                tempLista2.remove(item);
	            }
	        }        
	        // Se tutti gli elementi di lista1 sono stati trovati, aumenta il counter
	        nListe1InLista2++;
        }
        return nListe1InLista2;
    }
    
	public static ObjectiveCard drawObjectiveCards(int n) {
		ObjectiveCard card = null;
		return card;
	}
	
	private enum RequirementType {
		SYMBOL_REQUIREMENT, SPECIALSYMBOL_REQUIREMENT, POSITION_REQUIREMENT;
	}

	public RequirementType getRequirementType() {
		return requirementType;
	}


	public void setRequirementType(RequirementType requirementType) {
		this.requirementType = requirementType;
	}


	public ArrayList<Symbol> getSymbolRequirement() {
		return symbolRequirement;
	}


	public void setSymbolRequirement(ArrayList<Symbol> symbolRequirement) {
		this.symbolRequirement = symbolRequirement;
	}


	public ArrayList<SpecialSymbol> getSpecialSymbolRequirement() {
		return specialSymbolRequirement;
	}


	public void setSpecialSymbolRequirement(ArrayList<SpecialSymbol> specialSymbolRequirement) {
		this.specialSymbolRequirement = specialSymbolRequirement;
	}


	public Object[][] getPositionRequirement() {
		return positionRequirement;
	}


	public void setPositionRequirement(Object[][] positionRequirement) {
		this.positionRequirement = positionRequirement;
	}


	public int getPointsPerRequirement() {
		return pointsPerRequirement;
	}


	public void setPointsPerRequirement(int pointsPerRequirement) {
		this.pointsPerRequirement = pointsPerRequirement;
	}


	@Override
	public String getAbbreviatedCorner(CornerPosition cornertype) {
		// TODO Auto-generated method stub
		return null;
	}
	@Override
	public Object[][] getPointsAssignment() {
		// TODO Auto-generated method stub
		return null;
	}
	@Override
	public CardType getType() {
		return this.type;
	}

}




