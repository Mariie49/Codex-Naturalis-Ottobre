/* GAME
	
	startGame()
		Fa un botto di roba, anche troppa:
		1) Scelta di numero giocatori
		2) Pesca e piazza 4 carte sul tavolo visibili a tutti. 2 Resource e 2 Oro, TODO aggiungere le carte obiettivo.
		3) ogni giocatore:
			3.1) Pesca 2 carte risorsa e una oro
			3.2) Pesca carta Iniziale
			3.3) Sceglie fronte e retro di carta iniziale
			3.4) Colloca carta iniziale su PlayArea
		4) Mischia la lista dei giocatori
		
	turn(Player currentPlayer) WORK IN PROGRESS <<<<<<<<<<<<<<
		Il giocatore corrente:
		1)
			
 */


package game;
import resourceCard.*;
import cards.*;
import goldCard.*;
import initialCard.*;
import objectivecards.ObjectiveCard;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.Random;
import java.util.Scanner;



public class Game {

	private ArrayList<Player> playerList;
	//private ArrayList<ObjectiveCard> commonObjCard;
	private ArrayList<Card> visibleCards;
	private int[] playerScores;
	private int[] playerTurnsPlayed;
	private ArrayList<Card> handPlayerCards;
	private PlayArea matchManuscript;
	private int numPlayers;
	private int currentTurn = 0;
	private boolean lastRound  = false;
	private int maxTurns;
	private final Scanner sc = new Scanner(System.in);


	public ArrayList<Player> getPlayerList() {
		return playerList;
	}



	public Game() {
		// Inizializzo la lista dei giocatori e delle loro playareas
		playerList = new ArrayList<Player>();
		
		GoldCard.resetGoldCards();
		ResourceCard.resetResourceCards();
		InitialCard.resetInirialCards();
		//ObjectiveCard.resetObjectiveCards;
		
		visibleCards = new ArrayList<Card>();
		currentTurn = 0;
		maxTurns = 0;
		//matchBoard = new Board();

	}

	public void startGame() {	
		// ------------ Scelta numero di giocatori ------------
		boolean bypass_numeroGiocatori = false; // bypass scelta giocatori
		
		if (!bypass_numeroGiocatori) {
			String name;
			numPlayers = 0; //variabile che conta il numero di giocatori
			do {
	            System.out.print("Quanti giocatori parteciperanno (da 2 a 4)?");
	            numPlayers = sc.nextInt();
	            if (numPlayers < 2 || numPlayers > 4) {
	            	System.out.print("Numero di giocatori non valido\n");
	            }
	        } while (numPlayers < 2 || numPlayers > 4);			
			int ii = 1;
			do {
				System.out.println("Inserisci il nome del giocatore: " + (ii));
				name = sc.next();
				boolean isDuplicated = false;
				for (Player p : playerList) {
					if (p.getName().equalsIgnoreCase(name)) { 
						isDuplicated = true;
						break; 
					}
				}
				if (isDuplicated) {
					System.out.println("Nome gi� utilizzato. Per favore, inserisci un nome diverso.");
				} else {
					playerList.add(new Player(ii, name));
					ii++;
				}
			} while ( ii < numPlayers+1);
		}
		else {
			numPlayers = 1;
			playerList.add(new Player(1, "zio Adolfo"));
		}
		
		// ------------ Stampa i nomi dei giocatori ------------
		System.out.print("I giocatori sono: " + " ");
		for (Player s : playerList) {
			System.out.print(s.getName() + " ");
		}
		System.out.println();
		// ------------ ------------
		
		playerScores = new int[numPlayers + 1]; // inizializzazione punteggi
		playerTurnsPlayed = new int[numPlayers + 1];
		
		// ------------ Colloca 4 carte sul tavolo ------------
		for (int i = 0; i < 2; i++) {
			
			// Due carte risorsa visibili
			ResourceCard visibleResourceCard = ResourceCard.drawResourceCard();
			if (visibleResourceCard == null) {
			    System.err.println("Attenzione: la carta risorsa estratta è null!");
			} else {
			    visibleCards.add(visibleResourceCard);
			}

			// Due carte oro visibili
			GoldCard visibleGoldCard = GoldCard.drawGoldCard();
			if (visibleGoldCard == null) {
			    System.err.println("Attenzione: la carta oro estratta è null!");
			} else {
			    visibleCards.add(visibleGoldCard);
			}	

			// due carte obiettivo comuni
			//   ObjectiveCard comObjectiveCard = ObjectiveCard.drawCard();
			//   commonObjCard.add(comObjectiveCard);
		}

		// ------------ Stampa le carte presenti sul tavolo ------------
		System.out.println("Ecco le prime carte disponibili sul tavolo: 2 carte oro e 2 carte risorsa. ");
		for (Card r : visibleCards) {
			System.out.println();
			r.printCard();
			System.out.println();
		}	
		
		// ------------ Stampa le carte presenti sul tavolo ------------
		for (Player player : playerList) {
			
			matchManuscript = new PlayArea();
			player.setPlayArea(matchManuscript);
			
			System.out.println(" " + player.getName());
			System.out.println("Pesco 2 carte risorsa e una carta oro. ");
			for (int i = 0; i < 2; i++) {
				Card resourceHandCard = ResourceCard.drawResourceCard();
				if (resourceHandCard == null) {
				    System.err.println("Attenzione: la carta risorsa estratta è null!");
				} else {
					player.addCardToHand(resourceHandCard);
				}				
				resourceHandCard.printCard();				
			}

			Card goldHandCard = GoldCard.drawGoldCard();
			if (goldHandCard == null) {
			    System.err.println("Attenzione: la carta Gold estratta è null! Game>Startgame");
			} else {
				player.addCardToHand(goldHandCard);
			}				
			goldHandCard.printCard();


			// Draw one initial card from the initial deck, choose orientation and place initial card
			InitialCard initialHandCard = InitialCard.drawInitialCard(); 
			//restituisce la carta nel verso scelto 

			//System.out.println(initialHandCard.getInitialCardNumber());
			player.chooseOrientationAndPlaceInitialCard(initialHandCard); 

			// Draw two objective cards from the objective deck and choose one
			/*
			 *  ObjectiveCard objectiveFirstHandCards = ObjectiveCard.drawCard();
			 *  ObjectiveCard objectiveSecondHandCards = ObjectiveCard.drawCard();

	                ObjectiveCard objectiveHandCards = player.chooseObjectiveCard(objectiveFirstHandCards, objectiveSecondHandCards);
			 */

		}

		Collections.shuffle(playerList);
		playerList.get(0).setIsFirst(true);
	}

	public boolean turn (Player currentPlayer) {
		Card cardToTake = null;
		ArrayList<Cell> availableCells;
		boolean cardPlaced = false;
		currentTurn++;
		
		playerTurnsPlayed[currentPlayer.getId()]++;
		
		System.out.println("Tocca a " + currentPlayer.getName());
		currentPlayer.getPlayArea().printPlayArea();		
		
		Card chosenCard = currentPlayer.chooseCardToPlay();
		
		CornerPosition chosenCornerPosition = currentPlayer.choosePosition(); // Il giocatore sceglie la cornerposition
		
		Coordinates chosenCoordinates = currentPlayer.chooseViablePositionOnPlayArea(chosenCard, chosenCornerPosition); // Il giocatore sceglie le coordinate
				
		currentPlayer.addCardToPlayArea(chosenCard, chosenCornerPosition , chosenCoordinates);
		

    	
    	System.out.println("siamo qua: Game > turn. La nuova PlayArea è:\n");
		currentPlayer.getPlayArea().printPlayArea();
		
		
		
		System.exit(0);
		
		

		if ( !lastRound  || (playerScores[currentPlayer.getId()]  >= 20 && !lastRound)) {
			lastRound = true; 
		}

		if (lastRound) {

			if (playerTurnsPlayed[currentPlayer.getId()] < getMaxTurnsPlayed()) {

				System.out.println("Ultimo Round - Giocatore " + currentPlayer.getName());
				System.out.println("\nManoscritto del giocatore " + currentPlayer.getName() + " all'inizio del turno:");
		        currentPlayer.getPlayArea().printPlayArea();
		        
		        
			}
		} else {
			
			System.out.println("Turno " + currentTurn + " - Giocatore " + currentPlayer.getName());
			System.out.println("\nManoscritto del giocatore " + currentPlayer.getName() + " all'inizio del turno:");
			
	        currentPlayer.getPlayArea().printPlayArea();
	        
	        System.out.println("Sono arrivato qui, spero.");
	        System.exit(0);
	        
			chosenCard = currentPlayer.chooseCardToPlay();
			
			
/*
			availableCells = matchManuscript.getAvailableDiagonalCells();
			System.out.println("Celle disponibili:");
			for (Cell cell : availableCells) {
				System.out.println("(" + cell.getX() + ", " + cell.getY() + ")");
			}

			while (!cardPlaced) {
				try {
					System.out.print("Inserisci la coordinata x: ");
					int x = sc.nextInt(); 

					System.out.print("Inserisci la coordinata y: ");
					int y = sc.nextInt(); 

					matchManuscript.placeCardInManuscript(cardToPlay, x, y);
					cardPlaced = true; 

				} catch (IllegalArgumentException e) {
					if (e.getMessage().contains("Posizione non valida nel manoscritto")) {
						System.out.println("Coordinate non valide. Riprova.");
						availableCells = matchManuscript.getAvailableDiagonalCells();
						System.out.println("Celle disponibili:");
						for (Cell cell : availableCells) {
							System.out.println("(" + cell.getX() + ", " + cell.getY() + ")");
						}
					} else {
						System.out.println("Errore: " + e.getMessage());
						System.out.println("Riprova a inserire la carta.");
					}
				}
			}
			playerScores[currentPlayer.getId()] += currentPlayer.getPoints();
			if ( isGameOver() || (lastRound && allPlayersHadLastTurn())) {
				endGame();
			}





			matchManuscript = currentPlayer.getPlayArea();

			cardToPlay = currentPlayer.chooseCardToPlay();




			do {
				cardToTake = currentPlayer.chooseCardToTake(visibleCards);

			}while(cardToTake == null);


			currentPlayer.addCardToHand(cardToTake);


			System.out.println("\nManoscritto del giocatore " + currentPlayer.getName() + " alla fine del turno:");
	        currentPlayer.getPlayArea().printManuscript();
			updatevisibleCards();
			return true;
			*/
		}
		

		//da fare
		if (lastRound && allPlayersHadLastTurn()) {
			endGame();
		}



		return false;
	}




	private int getMaxTurnsPlayed() {
		int maxTurns = 0;
		for (int turns : playerTurnsPlayed) {
			maxTurns = Math.max(maxTurns, turns);
		}
		return maxTurns;
	}

	private boolean allPlayersHadLastTurn() {
		for (int turns : playerTurnsPlayed) {
			if (turns < getMaxTurnsPlayed()) {
				return false;
			}
		}
		return true;
	}

	private void endGame() {
		//da fare
		System.out.println("Partita terminata!");
	}

	/**
	 * Verifica se l'utente risponde si oppure no. Le valide risposte sono : 'Y', 'Yes', 'yes', 'N', 'No', or 'no'
	 *
	 * @return true is the answer is yes
	 */
	public boolean checkAnswer() {
		String choice;
		boolean flag;
		choice = sc.next();
		//while(!choice.contains("y") || !choice.equals("Yes") || !choice.equals("yes") || !choice.equals("N") || !choice.equals("No") || !choice.equals("no")) 
		while (!choice.startsWith("s") && !choice.startsWith("S") && !choice.startsWith("n") && !choice.startsWith("N")) {
			System.out.println("La risposta non � corretta. Rispondi si oppure no. ");
			choice = sc.next();
		}
		flag = choice.startsWith("s") || choice.startsWith("S");

		return flag;
	}

	

	private boolean isGameOver() {
		
		for (Player player : playerList) {
			if (player.getPoints() >= 20 ) {
				return true;
			}
		}
		return false;
	}

	
	//da fare
	private void determineWinner() {
		Player winner = null;
		int maxScore = Integer.MIN_VALUE;

		
		for (Player player : playerList) {
			if (player.getPoints() > maxScore) {
				maxScore = player.getPoints();
				winner = player;
			}
		}

		// pareggio?
		ArrayList <Player> winners = new ArrayList<>();
		for (Player player : playerList) {
			if (player.getPoints() == maxScore) {
				winners.add(player);
			}
		}

		
		if (winners.size() == 1) {
			System.out.println("Il vincitore �: " + winners.get(0).getName());
		} else {
			System.out.println("Pareggio! Il vincitore �:");
			for (Player player : winners) {
				System.out.println(player.getName());
			}
		}
	}







	public ArrayList<Player> rankings(){
		ArrayList<Player> sortedRanking;
		sortedRanking = playerList;
		// Setting up the comparator, the reversed flag is to have a decrescent order
		Comparator <Player> scoreComparator = Comparator.comparingInt(Player :: totalPoints).reversed();

		// Sorting the ArrayList with the Comparator
		Collections.sort(sortedRanking, scoreComparator);
		return sortedRanking;
	}

	/**
	 * Fast way to print an ArrayList of Cards with an index on top of the row
	 *
	 * @param cards
	 */
	public void printCardArrayList(ArrayList<Card> genericCards) {

		for (int i = 0; i < genericCards.size(); i++) {
			System.out.print(i + "\t");
		}
		System.out.println();

		for (int i = 0; i < genericCards.size(); i++) {
			System.out.print(genericCards.get(i) + "\t");
		}
		System.out.println();
	}

	private void updatevisibleCards() {
		int goldCount = 0;
		int resourceCount = 0;


		// Analisi delle carte visibili
		for (Card card : visibleCards) {
			if (card.getType() == CardType.GOLD) {
				goldCount++;
			} else if (card.getType() == CardType.RESOURCE) {
				resourceCount++;
			}
		}

		// Pesca delle nuove carte (se necessario)
		while (goldCount < 2) {
			Card gold = GoldCard.drawGoldCard(); // Metodo ipotetico per pescare una carta specifica
			if (gold != null) {
				visibleCards.add(gold);
				goldCount++;
			} else {
				lastRound = true;
				System.out.println("Carte oro sono finite. Fine gioco.");
				break; 
			}
		}

		while (resourceCount < 2) {
			Card resource = ResourceCard.drawResourceCard();
			if (resource != null) {
				visibleCards.add(resource);
				resourceCount++;
			} else {
				lastRound = true;
				System.out.println("Carte risorsa sono finite. Fine gioco. ");
				break;
			}
		}

	}




	public PlayArea getplayArea() {
		return matchManuscript;
	}
}
